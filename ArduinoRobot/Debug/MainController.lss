
MainController.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000004  00800100  00000994  00000a28  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000994  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000005c  00800104  00800104  00000a2c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000a2c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000a5c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000178  00000000  00000000  00000a9c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001330  00000000  00000000  00000c14  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000007a8  00000000  00000000  00001f44  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000ba0  00000000  00000000  000026ec  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000004a4  00000000  00000000  0000328c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000008fb  00000000  00000000  00003730  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000bee  00000000  00000000  0000402b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000168  00000000  00000000  00004c19  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 5f 02 	jmp	0x4be	; 0x4be <__vector_1>
   8:	0c 94 86 02 	jmp	0x50c	; 0x50c <__vector_2>
   c:	0c 94 ae 02 	jmp	0x55c	; 0x55c <__vector_3>
  10:	0c 94 ba 02 	jmp	0x574	; 0x574 <__vector_4>
  14:	0c 94 c6 02 	jmp	0x58c	; 0x58c <__vector_5>
  18:	0c 94 d2 02 	jmp	0x5a4	; 0x5a4 <__vector_6>
  1c:	0c 94 de 02 	jmp	0x5bc	; 0x5bc <__vector_7>
  20:	0c 94 32 03 	jmp	0x664	; 0x664 <__vector_8>
  24:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__vector_9>
  28:	0c 94 4a 03 	jmp	0x694	; 0x694 <__vector_10>
  2c:	0c 94 83 03 	jmp	0x706	; 0x706 <__vector_11>
  30:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__vector_12>
  34:	0c 94 9b 03 	jmp	0x736	; 0x736 <__vector_13>
  38:	0c 94 aa 03 	jmp	0x754	; 0x754 <__vector_14>
  3c:	0c 94 b6 03 	jmp	0x76c	; 0x76c <__vector_15>
  40:	0c 94 c2 03 	jmp	0x784	; 0x784 <__vector_16>
  44:	0c 94 ce 03 	jmp	0x79c	; 0x79c <__vector_17>
  48:	0c 94 da 03 	jmp	0x7b4	; 0x7b4 <__vector_18>
  4c:	0c 94 ee 03 	jmp	0x7dc	; 0x7dc <__vector_19>
  50:	0c 94 fd 03 	jmp	0x7fa	; 0x7fa <__vector_20>
  54:	0c 94 11 04 	jmp	0x822	; 0x822 <__vector_21>
  58:	0c 94 20 04 	jmp	0x840	; 0x840 <__vector_22>
  5c:	0c 94 2c 04 	jmp	0x858	; 0x858 <__vector_23>
  60:	0c 94 38 04 	jmp	0x870	; 0x870 <__vector_24>
  64:	0c 94 6c 04 	jmp	0x8d8	; 0x8d8 <__vector_25>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	11 e0       	ldi	r17, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	e4 e9       	ldi	r30, 0x94	; 148
  7c:	f9 e0       	ldi	r31, 0x09	; 9
  7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0
  84:	a4 30       	cpi	r26, 0x04	; 4
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
  8a:	21 e0       	ldi	r18, 0x01	; 1
  8c:	a4 e0       	ldi	r26, 0x04	; 4
  8e:	b1 e0       	ldi	r27, 0x01	; 1
  90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
  92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
  94:	a0 36       	cpi	r26, 0x60	; 96
  96:	b2 07       	cpc	r27, r18
  98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
  9a:	0e 94 6f 01 	call	0x2de	; 0x2de <main>
  9e:	0c 94 c8 04 	jmp	0x990	; 0x990 <_exit>

000000a2 <setPin>:
		TXData[TXBufferInPos] = data;			// Put Data in buffer
		TXBufferAmount ++;						// Increment elements count in TX buffer
		if(TXBufferInPos<(USARTBUFFER-1)){		// Check if end of buffer
			TXBufferInPos ++;					// Append at the end of buffer
		}else{									//
			TXBufferInPos = 0;					// Back to beginning of buffer
  a2:	9e ef       	ldi	r25, 0xFE	; 254
  a4:	98 0f       	add	r25, r24
  a6:	9c 30       	cpi	r25, 0x0C	; 12
  a8:	a8 f4       	brcc	.+42     	; 0xd4 <setPin+0x32>
  aa:	5a b1       	in	r21, 0x0a	; 10
  ac:	26 2f       	mov	r18, r22
  ae:	30 e0       	ldi	r19, 0x00	; 0
  b0:	09 2e       	mov	r0, r25
  b2:	02 c0       	rjmp	.+4      	; 0xb8 <setPin+0x16>
  b4:	22 0f       	add	r18, r18
  b6:	33 1f       	adc	r19, r19
  b8:	0a 94       	dec	r0
  ba:	e2 f7       	brpl	.-8      	; 0xb4 <setPin+0x12>
  bc:	25 2b       	or	r18, r21
  be:	2a b9       	out	0x0a, r18	; 10
  c0:	5b b1       	in	r21, 0x0b	; 11
  c2:	24 2f       	mov	r18, r20
  c4:	30 e0       	ldi	r19, 0x00	; 0
  c6:	02 c0       	rjmp	.+4      	; 0xcc <setPin+0x2a>
  c8:	22 0f       	add	r18, r18
  ca:	33 1f       	adc	r19, r19
  cc:	9a 95       	dec	r25
  ce:	e2 f7       	brpl	.-8      	; 0xc8 <setPin+0x26>
  d0:	25 2b       	or	r18, r21
  d2:	2b b9       	out	0x0b, r18	; 11
  d4:	92 ef       	ldi	r25, 0xF2	; 242
  d6:	98 0f       	add	r25, r24
  d8:	96 30       	cpi	r25, 0x06	; 6
  da:	a8 f4       	brcc	.+42     	; 0x106 <setPin+0x64>
  dc:	54 b1       	in	r21, 0x04	; 4
  de:	26 2f       	mov	r18, r22
  e0:	30 e0       	ldi	r19, 0x00	; 0
  e2:	09 2e       	mov	r0, r25
  e4:	02 c0       	rjmp	.+4      	; 0xea <setPin+0x48>
  e6:	22 0f       	add	r18, r18
  e8:	33 1f       	adc	r19, r19
  ea:	0a 94       	dec	r0
  ec:	e2 f7       	brpl	.-8      	; 0xe6 <setPin+0x44>
  ee:	25 2b       	or	r18, r21
  f0:	24 b9       	out	0x04, r18	; 4
  f2:	55 b1       	in	r21, 0x05	; 5
  f4:	24 2f       	mov	r18, r20
  f6:	30 e0       	ldi	r19, 0x00	; 0
  f8:	02 c0       	rjmp	.+4      	; 0xfe <setPin+0x5c>
  fa:	22 0f       	add	r18, r18
  fc:	33 1f       	adc	r19, r19
  fe:	9a 95       	dec	r25
 100:	e2 f7       	brpl	.-8      	; 0xfa <setPin+0x58>
 102:	25 2b       	or	r18, r21
 104:	25 b9       	out	0x05, r18	; 5
 106:	87 51       	subi	r24, 0x17	; 23
 108:	86 30       	cpi	r24, 0x06	; 6
 10a:	98 f4       	brcc	.+38     	; 0x132 <setPin+0x90>
 10c:	97 b1       	in	r25, 0x07	; 7
 10e:	70 e0       	ldi	r23, 0x00	; 0
 110:	08 2e       	mov	r0, r24
 112:	02 c0       	rjmp	.+4      	; 0x118 <setPin+0x76>
 114:	66 0f       	add	r22, r22
 116:	77 1f       	adc	r23, r23
 118:	0a 94       	dec	r0
 11a:	e2 f7       	brpl	.-8      	; 0x114 <setPin+0x72>
 11c:	69 2b       	or	r22, r25
 11e:	67 b9       	out	0x07, r22	; 7
 120:	98 b1       	in	r25, 0x08	; 8
 122:	50 e0       	ldi	r21, 0x00	; 0
 124:	02 c0       	rjmp	.+4      	; 0x12a <setPin+0x88>
 126:	44 0f       	add	r20, r20
 128:	55 1f       	adc	r21, r21
 12a:	8a 95       	dec	r24
 12c:	e2 f7       	brpl	.-8      	; 0x126 <setPin+0x84>
 12e:	49 2b       	or	r20, r25
 130:	48 b9       	out	0x08, r20	; 8
 132:	08 95       	ret

00000134 <initErrorPin>:
 134:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
 138:	40 e0       	ldi	r20, 0x00	; 0
 13a:	61 e0       	ldi	r22, 0x01	; 1
 13c:	0e 94 51 00 	call	0xa2	; 0xa2 <setPin>
 140:	08 95       	ret

00000142 <setError>:
 142:	80 93 0b 01 	sts	0x010B, r24	; 0x80010b <errorCode>
 146:	41 e0       	ldi	r20, 0x01	; 1
 148:	61 e0       	ldi	r22, 0x01	; 1
 14a:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
 14e:	0e 94 51 00 	call	0xa2	; 0xa2 <setPin>
 152:	08 95       	ret

00000154 <initTimer>:
 154:	cf 93       	push	r28
 156:	90 93 0f 01 	sts	0x010F, r25	; 0x80010f <prescalerTimer+0x1>
 15a:	80 93 0e 01 	sts	0x010E, r24	; 0x80010e <prescalerTimer>
 15e:	22 e0       	ldi	r18, 0x02	; 2
 160:	20 93 b0 00 	sts	0x00B0, r18	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
 164:	80 34       	cpi	r24, 0x40	; 64
 166:	91 05       	cpc	r25, r1
 168:	11 f1       	breq	.+68     	; 0x1ae <initTimer+0x5a>
 16a:	48 f4       	brcc	.+18     	; 0x17e <initTimer+0x2a>
 16c:	88 30       	cpi	r24, 0x08	; 8
 16e:	91 05       	cpc	r25, r1
 170:	b1 f0       	breq	.+44     	; 0x19e <initTimer+0x4a>
 172:	80 32       	cpi	r24, 0x20	; 32
 174:	91 05       	cpc	r25, r1
 176:	b9 f0       	breq	.+46     	; 0x1a6 <initTimer+0x52>
 178:	01 97       	sbiw	r24, 0x01	; 1
 17a:	49 f5       	brne	.+82     	; 0x1ce <initTimer+0x7a>
 17c:	0c c0       	rjmp	.+24     	; 0x196 <initTimer+0x42>
 17e:	81 15       	cp	r24, r1
 180:	21 e0       	ldi	r18, 0x01	; 1
 182:	92 07       	cpc	r25, r18
 184:	e1 f0       	breq	.+56     	; 0x1be <initTimer+0x6a>
 186:	81 15       	cp	r24, r1
 188:	24 e0       	ldi	r18, 0x04	; 4
 18a:	92 07       	cpc	r25, r18
 18c:	e1 f0       	breq	.+56     	; 0x1c6 <initTimer+0x72>
 18e:	80 38       	cpi	r24, 0x80	; 128
 190:	91 05       	cpc	r25, r1
 192:	e9 f4       	brne	.+58     	; 0x1ce <initTimer+0x7a>
 194:	10 c0       	rjmp	.+32     	; 0x1b6 <initTimer+0x62>
 196:	81 e0       	ldi	r24, 0x01	; 1
 198:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7e00b1>
 19c:	1b c0       	rjmp	.+54     	; 0x1d4 <initTimer+0x80>
 19e:	82 e0       	ldi	r24, 0x02	; 2
 1a0:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7e00b1>
 1a4:	17 c0       	rjmp	.+46     	; 0x1d4 <initTimer+0x80>
 1a6:	83 e0       	ldi	r24, 0x03	; 3
 1a8:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7e00b1>
 1ac:	13 c0       	rjmp	.+38     	; 0x1d4 <initTimer+0x80>
 1ae:	84 e0       	ldi	r24, 0x04	; 4
 1b0:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7e00b1>
 1b4:	0f c0       	rjmp	.+30     	; 0x1d4 <initTimer+0x80>
 1b6:	85 e0       	ldi	r24, 0x05	; 5
 1b8:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7e00b1>
 1bc:	0b c0       	rjmp	.+22     	; 0x1d4 <initTimer+0x80>
 1be:	86 e0       	ldi	r24, 0x06	; 6
 1c0:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7e00b1>
 1c4:	07 c0       	rjmp	.+14     	; 0x1d4 <initTimer+0x80>
 1c6:	87 e0       	ldi	r24, 0x07	; 7
 1c8:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7e00b1>
 1cc:	03 c0       	rjmp	.+6      	; 0x1d4 <initTimer+0x80>
 1ce:	87 e0       	ldi	r24, 0x07	; 7
 1d0:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7e00b1>
 1d4:	c2 e0       	ldi	r28, 0x02	; 2
 1d6:	c0 93 b1 00 	sts	0x00B1, r28	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7e00b1>
 1da:	20 91 0e 01 	lds	r18, 0x010E	; 0x80010e <prescalerTimer>
 1de:	30 91 0f 01 	lds	r19, 0x010F	; 0x80010f <prescalerTimer+0x1>
 1e2:	22 0f       	add	r18, r18
 1e4:	33 1f       	adc	r19, r19
 1e6:	a0 e5       	ldi	r26, 0x50	; 80
 1e8:	b3 ec       	ldi	r27, 0xC3	; 195
 1ea:	0e 94 b9 04 	call	0x972	; 0x972 <__umulhisi3>
 1ee:	9b 01       	movw	r18, r22
 1f0:	ac 01       	movw	r20, r24
 1f2:	60 e0       	ldi	r22, 0x00	; 0
 1f4:	74 e2       	ldi	r23, 0x24	; 36
 1f6:	84 ef       	ldi	r24, 0xF4	; 244
 1f8:	90 e0       	ldi	r25, 0x00	; 0
 1fa:	0e 94 78 04 	call	0x8f0	; 0x8f0 <__udivmodsi4>
 1fe:	22 50       	subi	r18, 0x02	; 2
 200:	20 93 b3 00 	sts	0x00B3, r18	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7e00b3>
 204:	c0 93 70 00 	sts	0x0070, r28	; 0x800070 <__TEXT_REGION_LENGTH__+0x7e0070>
 208:	10 92 b2 00 	sts	0x00B2, r1	; 0x8000b2 <__TEXT_REGION_LENGTH__+0x7e00b2>
 20c:	cf 91       	pop	r28
 20e:	08 95       	ret

00000210 <initUSART>:
 210:	40 e0       	ldi	r20, 0x00	; 0
 212:	60 e0       	ldi	r22, 0x00	; 0
 214:	82 e0       	ldi	r24, 0x02	; 2
 216:	0e 94 51 00 	call	0xa2	; 0xa2 <setPin>
 21a:	40 e0       	ldi	r20, 0x00	; 0
 21c:	61 e0       	ldi	r22, 0x01	; 1
 21e:	83 e0       	ldi	r24, 0x03	; 3
 220:	0e 94 51 00 	call	0xa2	; 0xa2 <setPin>
 224:	87 e6       	ldi	r24, 0x67	; 103
 226:	90 e0       	ldi	r25, 0x00	; 0
 228:	90 93 c5 00 	sts	0x00C5, r25	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
 22c:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
 230:	88 ed       	ldi	r24, 0xD8	; 216
 232:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
 236:	8e e0       	ldi	r24, 0x0E	; 14
 238:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
 23c:	08 95       	ret

0000023e <readUSART>:
		//setError(USART_TX_BUFFER_FULL);			// Set error if buffer is full
	}
}
uint8_t readUSART(){
	uint8_t result = 0;							// Initialize result
	if(RXBufferAmount>0){						// Check if unread data are in the RX buffer
 23e:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <RXBufferAmount>
 242:	88 23       	and	r24, r24
 244:	a9 f0       	breq	.+42     	; 0x270 <readUSART+0x32>
		result = RXData[RXBufferOutPos];		// Get Data from the buffer
 246:	90 91 38 01 	lds	r25, 0x0138	; 0x800138 <RXBufferOutPos>
 24a:	e9 2f       	mov	r30, r25
 24c:	f0 e0       	ldi	r31, 0x00	; 0
 24e:	e0 5b       	subi	r30, 0xB0	; 176
 250:	fe 4f       	sbci	r31, 0xFE	; 254
 252:	80 81       	ld	r24, Z
		if(RXBufferOutPos<(USARTBUFFER-1)){		// Check if end of buffer
 254:	97 30       	cpi	r25, 0x07	; 7
 256:	20 f4       	brcc	.+8      	; 0x260 <readUSART+0x22>
			RXBufferOutPos ++;					// Increment RX output position
 258:	9f 5f       	subi	r25, 0xFF	; 255
 25a:	90 93 38 01 	sts	0x0138, r25	; 0x800138 <RXBufferOutPos>
 25e:	02 c0       	rjmp	.+4      	; 0x264 <readUSART+0x26>
		}else{									//
			RXBufferOutPos = 0;					// Back to start of buffer
 260:	10 92 38 01 	sts	0x0138, r1	; 0x800138 <RXBufferOutPos>
		}
		RXBufferAmount--;						// Decrement number of elements in the buffer
 264:	90 91 37 01 	lds	r25, 0x0137	; 0x800137 <RXBufferAmount>
 268:	91 50       	subi	r25, 0x01	; 1
 26a:	90 93 37 01 	sts	0x0137, r25	; 0x800137 <RXBufferAmount>
 26e:	08 95       	ret
	}else{
		//setError(USART_TX_BUFFER_FULL);			// Set error if buffer is full
	}
}
uint8_t readUSART(){
	uint8_t result = 0;							// Initialize result
 270:	80 e0       	ldi	r24, 0x00	; 0
		RXBufferAmount--;						// Decrement number of elements in the buffer
	}else{
		//setError(USART_RX_BUFFER_EMPTY);
	}
	return result;
}
 272:	08 95       	ret

00000274 <cycleTXUSART>:
void cycleTXUSART(){
	if(ISR_USARTTX){							// Check if previous TX is finished
 274:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <ISR_USARTTX>
 278:	88 23       	and	r24, r24
 27a:	a1 f0       	breq	.+40     	; 0x2a4 <cycleTXUSART+0x30>
		ISR_USARTTX = 0;						// Flag pending TX
 27c:	10 92 01 01 	sts	0x0101, r1	; 0x800101 <ISR_USARTTX>
		UDR0 = TXData[TXBufferOutPos];			// Put TX data in UDR register
 280:	e0 91 36 01 	lds	r30, 0x0136	; 0x800136 <TXBufferOutPos>
 284:	f0 e0       	ldi	r31, 0x00	; 0
 286:	e8 5a       	subi	r30, 0xA8	; 168
 288:	fe 4f       	sbci	r31, 0xFE	; 254
 28a:	80 81       	ld	r24, Z
 28c:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
		if(TXBufferOutPos<(USARTBUFFER-1)){		// Check if end of buffer
 290:	80 91 36 01 	lds	r24, 0x0136	; 0x800136 <TXBufferOutPos>
 294:	87 30       	cpi	r24, 0x07	; 7
 296:	20 f4       	brcc	.+8      	; 0x2a0 <cycleTXUSART+0x2c>
			TXBufferOutPos ++;					// Append at the end of buffer
 298:	8f 5f       	subi	r24, 0xFF	; 255
 29a:	80 93 36 01 	sts	0x0136, r24	; 0x800136 <TXBufferOutPos>
 29e:	08 95       	ret
		}else{									//
			TXBufferOutPos = 0;					// Back to start of buffer
 2a0:	10 92 36 01 	sts	0x0136, r1	; 0x800136 <TXBufferOutPos>
 2a4:	08 95       	ret

000002a6 <cycleRXUSART>:
	}else{
		//setError(USART_TX_BUSY);
	}
}
void cycleRXUSART(){
	if(RXBufferAmount<USARTBUFFER){				// Check if RX buffer is not full
 2a6:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <RXBufferAmount>
 2aa:	88 30       	cpi	r24, 0x08	; 8
 2ac:	a0 f4       	brcc	.+40     	; 0x2d6 <cycleRXUSART+0x30>
		RXData[RXBufferInPos] = UDR0;			// Add data to RX buffer
 2ae:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <RXBufferInPos>
 2b2:	90 91 c6 00 	lds	r25, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
 2b6:	e8 2f       	mov	r30, r24
 2b8:	f0 e0       	ldi	r31, 0x00	; 0
 2ba:	e0 5b       	subi	r30, 0xB0	; 176
 2bc:	fe 4f       	sbci	r31, 0xFE	; 254
 2be:	90 83       	st	Z, r25
		if(RXBufferInPos<(USARTBUFFER-1)){		// Check if end of buffer
 2c0:	87 30       	cpi	r24, 0x07	; 7
 2c2:	20 f4       	brcc	.+8      	; 0x2cc <cycleRXUSART+0x26>
			RXBufferInPos ++;					// Increment RX input position
 2c4:	8f 5f       	subi	r24, 0xFF	; 255
 2c6:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <RXBufferInPos>
 2ca:	02 c0       	rjmp	.+4      	; 0x2d0 <cycleRXUSART+0x2a>
		}else{									//
			RXBufferInPos  = 0;					// Back to beginning of buffer
 2cc:	10 92 39 01 	sts	0x0139, r1	; 0x800139 <RXBufferInPos>
		}
		ISR_USARTRX = 0;						// Flag new data can be received
 2d0:	10 92 41 01 	sts	0x0141, r1	; 0x800141 <ISR_USARTRX>
 2d4:	08 95       	ret
	}else{
		setError(USART_RX_BUFFER_FULL);
 2d6:	89 e2       	ldi	r24, 0x29	; 41
 2d8:	0e 94 a1 00 	call	0x142	; 0x142 <setError>
 2dc:	08 95       	ret

000002de <main>:
////////////////////////////// END FUNCTIONS DECLARATION //////////////////////////

int main (void){
////////////////////////////// SETUP //////////////////////////////////////////////
	//********** Pins configuration **********
	DDRB	= 0b00000110;						// Set pin direction (1=OUTPUT, 0=INPUT)
 2de:	86 e0       	ldi	r24, 0x06	; 6
 2e0:	84 b9       	out	0x04, r24	; 4
	DDRC	= 0b11111111;						//
 2e2:	8f ef       	ldi	r24, 0xFF	; 255
 2e4:	87 b9       	out	0x07, r24	; 7
	DDRD	= 0b11111111;						//
 2e6:	8a b9       	out	0x0a, r24	; 10
	
	PORTB	= 0b00000001;						// Set pin state :
 2e8:	81 e0       	ldi	r24, 0x01	; 1
 2ea:	85 b9       	out	0x05, r24	; 5
	PORTC	= 0b00000000;						// if OUTPUT: 1= HIGH, 0= LOWs
 2ec:	18 b8       	out	0x08, r1	; 8
	PORTD	= 0b00000000;						// if INPUT: 1= Pull-up on, 0= Pull-up off
 2ee:	1b b8       	out	0x0b, r1	; 11
	//********************

	//********** Services Initialization **********
	initErrorPin(errorPin);						// Mandatory services
 2f0:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
 2f4:	0e 94 9a 00 	call	0x134	; 0x134 <initErrorPin>
	initTimer();								//
 2f8:	0e 94 aa 00 	call	0x154	; 0x154 <initTimer>
	
	//initADC();
	//initPWM(TIMER0, SUPERSLOW);					// Initialize PWM Timer with frequency limiter (Hz)
	//initInputCapture(SUPERSLOW, RISING);
	initUSART(9600);
 2fc:	80 e8       	ldi	r24, 0x80	; 128
 2fe:	95 e2       	ldi	r25, 0x25	; 37
 300:	0e 94 08 01 	call	0x210	; 0x210 <initUSART>
	//initI2C();
	//********************
	
	//********** Global interrupts **********
	sei();
 304:	78 94       	sei
					if (prevCaptTimeCHA>inCaptTimeCHA){							// Prevents error when delteTime counter overflows
						deltaTimeCHA = (65536-prevCaptTimeCHA)+inCaptTimeCHA;	// 65536 = MAX counter value
					}else{
						deltaTimeCHA = inCaptTimeCHA-prevCaptTimeCHA;
					}
					HZCHA = calculateFrequency(deltaTimeCHA);
 306:	0f 2e       	mov	r0, r31
 308:	f0 e4       	ldi	r31, 0x40	; 64
 30a:	cf 2e       	mov	r12, r31
 30c:	f2 e4       	ldi	r31, 0x42	; 66
 30e:	df 2e       	mov	r13, r31
 310:	ff e0       	ldi	r31, 0x0F	; 15
 312:	ef 2e       	mov	r14, r31
 314:	f1 2c       	mov	r15, r1
 316:	f0 2d       	mov	r31, r0
				break;
			}
			ISR_TMR1CAPT = 0;
		}
		if(ISR_ADC){
			result_ADC = ADC;							// Transfer ADC result in holder variable
 318:	08 e7       	ldi	r16, 0x78	; 120
 31a:	10 e0       	ldi	r17, 0x00	; 0
		}
		//********************
		
		uint8_t USARTRX = readUSART();
		//uint8_t USARTRX = 255;
		DDRC = 0b11111111;
 31c:	cf ef       	ldi	r28, 0xFF	; 255
////////////////////////////// END SETUP /////////////////////////////////////////
	
	while(1) {
////////////////////////////// MAIN LOOP /////////////////////////////////////////		
		//********** ISR flags checks **********
		if(ISR_TMR1CAPT){
 31e:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <ISR_TMR1CAPT>
 322:	88 23       	and	r24, r24
 324:	09 f4       	brne	.+2      	; 0x328 <main+0x4a>
 326:	8d c0       	rjmp	.+282    	; 0x442 <__LOCK_REGION_LENGTH__+0x42>
			switch (lastInterruptChannel){
 328:	80 91 2a 01 	lds	r24, 0x012A	; 0x80012a <lastInterruptChannel>
 32c:	88 23       	and	r24, r24
 32e:	21 f0       	breq	.+8      	; 0x338 <main+0x5a>
 330:	81 30       	cpi	r24, 0x01	; 1
 332:	09 f4       	brne	.+2      	; 0x336 <main+0x58>
 334:	43 c0       	rjmp	.+134    	; 0x3bc <main+0xde>
 336:	83 c0       	rjmp	.+262    	; 0x43e <__LOCK_REGION_LENGTH__+0x3e>
				case 0:
					if (prevCaptTimeCHA>inCaptTimeCHA){							// Prevents error when delteTime counter overflows
 338:	20 91 12 01 	lds	r18, 0x0112	; 0x800112 <prevCaptTimeCHA>
 33c:	30 91 13 01 	lds	r19, 0x0113	; 0x800113 <prevCaptTimeCHA+0x1>
 340:	80 91 16 01 	lds	r24, 0x0116	; 0x800116 <inCaptTimeCHA>
 344:	90 91 17 01 	lds	r25, 0x0117	; 0x800117 <inCaptTimeCHA+0x1>
 348:	82 17       	cp	r24, r18
 34a:	93 07       	cpc	r25, r19
 34c:	78 f4       	brcc	.+30     	; 0x36c <main+0x8e>
						deltaTimeCHA = (65536-prevCaptTimeCHA)+inCaptTimeCHA;	// 65536 = MAX counter value
 34e:	80 91 16 01 	lds	r24, 0x0116	; 0x800116 <inCaptTimeCHA>
 352:	90 91 17 01 	lds	r25, 0x0117	; 0x800117 <inCaptTimeCHA+0x1>
 356:	20 91 12 01 	lds	r18, 0x0112	; 0x800112 <prevCaptTimeCHA>
 35a:	30 91 13 01 	lds	r19, 0x0113	; 0x800113 <prevCaptTimeCHA+0x1>
 35e:	82 1b       	sub	r24, r18
 360:	93 0b       	sbc	r25, r19
 362:	90 93 29 01 	sts	0x0129, r25	; 0x800129 <deltaTimeCHA+0x1>
 366:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <deltaTimeCHA>
 36a:	0e c0       	rjmp	.+28     	; 0x388 <main+0xaa>
					}else{
						deltaTimeCHA = inCaptTimeCHA-prevCaptTimeCHA;
 36c:	80 91 16 01 	lds	r24, 0x0116	; 0x800116 <inCaptTimeCHA>
 370:	90 91 17 01 	lds	r25, 0x0117	; 0x800117 <inCaptTimeCHA+0x1>
 374:	20 91 12 01 	lds	r18, 0x0112	; 0x800112 <prevCaptTimeCHA>
 378:	30 91 13 01 	lds	r19, 0x0113	; 0x800113 <prevCaptTimeCHA+0x1>
 37c:	82 1b       	sub	r24, r18
 37e:	93 0b       	sbc	r25, r19
 380:	90 93 29 01 	sts	0x0129, r25	; 0x800129 <deltaTimeCHA+0x1>
 384:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <deltaTimeCHA>
					}
					HZCHA = calculateFrequency(deltaTimeCHA);
 388:	40 91 28 01 	lds	r20, 0x0128	; 0x800128 <deltaTimeCHA>
 38c:	50 91 29 01 	lds	r21, 0x0129	; 0x800129 <deltaTimeCHA+0x1>
 390:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <inCaptTimeUnit>
 394:	90 91 0d 01 	lds	r25, 0x010D	; 0x80010d <inCaptTimeUnit+0x1>
 398:	48 9f       	mul	r20, r24
 39a:	90 01       	movw	r18, r0
 39c:	49 9f       	mul	r20, r25
 39e:	30 0d       	add	r19, r0
 3a0:	58 9f       	mul	r21, r24
 3a2:	30 0d       	add	r19, r0
 3a4:	11 24       	eor	r1, r1
 3a6:	40 e0       	ldi	r20, 0x00	; 0
 3a8:	50 e0       	ldi	r21, 0x00	; 0
 3aa:	c7 01       	movw	r24, r14
 3ac:	b6 01       	movw	r22, r12
 3ae:	0e 94 9a 04 	call	0x934	; 0x934 <__divmodsi4>
 3b2:	30 93 25 01 	sts	0x0125, r19	; 0x800125 <HZCHA+0x1>
 3b6:	20 93 24 01 	sts	0x0124, r18	; 0x800124 <HZCHA>
				break;
 3ba:	41 c0       	rjmp	.+130    	; 0x43e <__LOCK_REGION_LENGTH__+0x3e>
				case 1:
					if (prevCaptTimeCHB>inCaptTimeCHB){
 3bc:	20 91 10 01 	lds	r18, 0x0110	; 0x800110 <prevCaptTimeCHB>
 3c0:	30 91 11 01 	lds	r19, 0x0111	; 0x800111 <prevCaptTimeCHB+0x1>
 3c4:	80 91 14 01 	lds	r24, 0x0114	; 0x800114 <inCaptTimeCHB>
 3c8:	90 91 15 01 	lds	r25, 0x0115	; 0x800115 <inCaptTimeCHB+0x1>
 3cc:	82 17       	cp	r24, r18
 3ce:	93 07       	cpc	r25, r19
 3d0:	78 f4       	brcc	.+30     	; 0x3f0 <main+0x112>
						deltaTimeCHB = (65536-prevCaptTimeCHB)+inCaptTimeCHB;
 3d2:	80 91 14 01 	lds	r24, 0x0114	; 0x800114 <inCaptTimeCHB>
 3d6:	90 91 15 01 	lds	r25, 0x0115	; 0x800115 <inCaptTimeCHB+0x1>
 3da:	20 91 10 01 	lds	r18, 0x0110	; 0x800110 <prevCaptTimeCHB>
 3de:	30 91 11 01 	lds	r19, 0x0111	; 0x800111 <prevCaptTimeCHB+0x1>
 3e2:	82 1b       	sub	r24, r18
 3e4:	93 0b       	sbc	r25, r19
 3e6:	90 93 27 01 	sts	0x0127, r25	; 0x800127 <deltaTimeCHB+0x1>
 3ea:	80 93 26 01 	sts	0x0126, r24	; 0x800126 <deltaTimeCHB>
 3ee:	0e c0       	rjmp	.+28     	; 0x40c <__LOCK_REGION_LENGTH__+0xc>
					}else{
						deltaTimeCHB = inCaptTimeCHB-prevCaptTimeCHB;
 3f0:	80 91 14 01 	lds	r24, 0x0114	; 0x800114 <inCaptTimeCHB>
 3f4:	90 91 15 01 	lds	r25, 0x0115	; 0x800115 <inCaptTimeCHB+0x1>
 3f8:	20 91 10 01 	lds	r18, 0x0110	; 0x800110 <prevCaptTimeCHB>
 3fc:	30 91 11 01 	lds	r19, 0x0111	; 0x800111 <prevCaptTimeCHB+0x1>
 400:	82 1b       	sub	r24, r18
 402:	93 0b       	sbc	r25, r19
 404:	90 93 27 01 	sts	0x0127, r25	; 0x800127 <deltaTimeCHB+0x1>
 408:	80 93 26 01 	sts	0x0126, r24	; 0x800126 <deltaTimeCHB>
					}
					HZCHB = calculateFrequency(deltaTimeCHB);
 40c:	40 91 26 01 	lds	r20, 0x0126	; 0x800126 <deltaTimeCHB>
 410:	50 91 27 01 	lds	r21, 0x0127	; 0x800127 <deltaTimeCHB+0x1>
 414:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <inCaptTimeUnit>
 418:	90 91 0d 01 	lds	r25, 0x010D	; 0x80010d <inCaptTimeUnit+0x1>
 41c:	48 9f       	mul	r20, r24
 41e:	90 01       	movw	r18, r0
 420:	49 9f       	mul	r20, r25
 422:	30 0d       	add	r19, r0
 424:	58 9f       	mul	r21, r24
 426:	30 0d       	add	r19, r0
 428:	11 24       	eor	r1, r1
 42a:	40 e0       	ldi	r20, 0x00	; 0
 42c:	50 e0       	ldi	r21, 0x00	; 0
 42e:	c7 01       	movw	r24, r14
 430:	b6 01       	movw	r22, r12
 432:	0e 94 9a 04 	call	0x934	; 0x934 <__divmodsi4>
 436:	30 93 23 01 	sts	0x0123, r19	; 0x800123 <HZCHB+0x1>
 43a:	20 93 22 01 	sts	0x0122, r18	; 0x800122 <HZCHB>
				break;
			}
			ISR_TMR1CAPT = 0;
 43e:	10 92 49 01 	sts	0x0149, r1	; 0x800149 <ISR_TMR1CAPT>
		}
		if(ISR_ADC){
 442:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <ISR_ADC>
 446:	88 23       	and	r24, r24
 448:	59 f1       	breq	.+86     	; 0x4a0 <__LOCK_REGION_LENGTH__+0xa0>
			result_ADC = ADC;							// Transfer ADC result in holder variable
 44a:	f8 01       	movw	r30, r16
 44c:	80 81       	ld	r24, Z
 44e:	91 81       	ldd	r25, Z+1	; 0x01
 450:	90 93 3b 01 	sts	0x013B, r25	; 0x80013b <result_ADC+0x1>
 454:	80 93 3a 01 	sts	0x013A, r24	; 0x80013a <result_ADC>
			switch (channelADCinUse){
 458:	80 91 04 01 	lds	r24, 0x0104	; 0x800104 <__data_end>
 45c:	81 30       	cpi	r24, 0x01	; 1
 45e:	69 f0       	breq	.+26     	; 0x47a <__LOCK_REGION_LENGTH__+0x7a>
 460:	18 f0       	brcs	.+6      	; 0x468 <__LOCK_REGION_LENGTH__+0x68>
 462:	82 30       	cpi	r24, 0x02	; 2
 464:	99 f0       	breq	.+38     	; 0x48c <__LOCK_REGION_LENGTH__+0x8c>
 466:	1a c0       	rjmp	.+52     	; 0x49c <__LOCK_REGION_LENGTH__+0x9c>
				case 0:
					temperatureHBridge = result_ADC;
 468:	80 91 3a 01 	lds	r24, 0x013A	; 0x80013a <result_ADC>
 46c:	90 91 3b 01 	lds	r25, 0x013B	; 0x80013b <result_ADC+0x1>
 470:	90 93 0a 01 	sts	0x010A, r25	; 0x80010a <temperatureHBridge+0x1>
 474:	80 93 09 01 	sts	0x0109, r24	; 0x800109 <temperatureHBridge>
				break;
 478:	11 c0       	rjmp	.+34     	; 0x49c <__LOCK_REGION_LENGTH__+0x9c>
				case 1:
					temperatureMotor = result_ADC;
 47a:	80 91 3a 01 	lds	r24, 0x013A	; 0x80013a <result_ADC>
 47e:	90 91 3b 01 	lds	r25, 0x013B	; 0x80013b <result_ADC+0x1>
 482:	90 93 08 01 	sts	0x0108, r25	; 0x800108 <temperatureMotor+0x1>
 486:	80 93 07 01 	sts	0x0107, r24	; 0x800107 <temperatureMotor>
				break;
 48a:	08 c0       	rjmp	.+16     	; 0x49c <__LOCK_REGION_LENGTH__+0x9c>
				case 2:
					currentHBridge = result_ADC;
 48c:	80 91 3a 01 	lds	r24, 0x013A	; 0x80013a <result_ADC>
 490:	90 91 3b 01 	lds	r25, 0x013B	; 0x80013b <result_ADC+0x1>
 494:	90 93 06 01 	sts	0x0106, r25	; 0x800106 <currentHBridge+0x1>
 498:	80 93 05 01 	sts	0x0105, r24	; 0x800105 <currentHBridge>
				break;
				default:
					//setError(INVALID_ADC_CHANNEL);
				break;
			}
			ISR_ADC = 0;
 49c:	10 92 40 01 	sts	0x0140, r1	; 0x800140 <ISR_ADC>
		}
		if(ISR_USARTRX){
 4a0:	80 91 41 01 	lds	r24, 0x0141	; 0x800141 <ISR_USARTRX>
 4a4:	81 11       	cpse	r24, r1
			cycleRXUSART();		// Add received data to RX buffer
 4a6:	0e 94 53 01 	call	0x2a6	; 0x2a6 <cycleRXUSART>
		}
		if(TXBufferAmount>0){
 4aa:	80 91 35 01 	lds	r24, 0x0135	; 0x800135 <TXBufferAmount>
 4ae:	81 11       	cpse	r24, r1
			cycleTXUSART();		// Transmit data in TX buffer
 4b0:	0e 94 3a 01 	call	0x274	; 0x274 <cycleTXUSART>
		}
		//********************
		
		uint8_t USARTRX = readUSART();
 4b4:	0e 94 1f 01 	call	0x23e	; 0x23e <readUSART>
		//uint8_t USARTRX = 255;
		DDRC = 0b11111111;
 4b8:	c7 b9       	out	0x07, r28	; 7
		PORTC = USARTRX;
 4ba:	88 b9       	out	0x08, r24	; 8
		//clearError();
		//setPWM(12, result_ADC>>2);
		//I2CTransmit(128, READ, 255);
		//transmitUSART(result_ADC>>2);
////////////////////////////// END MAIN LOOP /////////////////////////////////////
	}
 4bc:	30 cf       	rjmp	.-416    	; 0x31e <main+0x40>

000004be <__vector_1>:
	}
}
////////////////////////////// END FUNCTIONS DEFINITIONS //////////////////////////

////////////////////////////// ISRs //////////////////////////
ISR(INT0_vect){									// External Interrupt Request 0
 4be:	1f 92       	push	r1
 4c0:	0f 92       	push	r0
 4c2:	0f b6       	in	r0, 0x3f	; 63
 4c4:	0f 92       	push	r0
 4c6:	11 24       	eor	r1, r1
 4c8:	8f 93       	push	r24
 4ca:	9f 93       	push	r25
 4cc:	af 93       	push	r26
 4ce:	bf 93       	push	r27
	pulsesEncCHA ++;
 4d0:	80 91 2f 01 	lds	r24, 0x012F	; 0x80012f <pulsesEncCHA>
 4d4:	90 91 30 01 	lds	r25, 0x0130	; 0x800130 <pulsesEncCHA+0x1>
 4d8:	a0 91 31 01 	lds	r26, 0x0131	; 0x800131 <pulsesEncCHA+0x2>
 4dc:	b0 91 32 01 	lds	r27, 0x0132	; 0x800132 <pulsesEncCHA+0x3>
 4e0:	01 96       	adiw	r24, 0x01	; 1
 4e2:	a1 1d       	adc	r26, r1
 4e4:	b1 1d       	adc	r27, r1
 4e6:	80 93 2f 01 	sts	0x012F, r24	; 0x80012f <pulsesEncCHA>
 4ea:	90 93 30 01 	sts	0x0130, r25	; 0x800130 <pulsesEncCHA+0x1>
 4ee:	a0 93 31 01 	sts	0x0131, r26	; 0x800131 <pulsesEncCHA+0x2>
 4f2:	b0 93 32 01 	sts	0x0132, r27	; 0x800132 <pulsesEncCHA+0x3>
	lastInterruptChannel = 0;
 4f6:	10 92 2a 01 	sts	0x012A, r1	; 0x80012a <lastInterruptChannel>
}
 4fa:	bf 91       	pop	r27
 4fc:	af 91       	pop	r26
 4fe:	9f 91       	pop	r25
 500:	8f 91       	pop	r24
 502:	0f 90       	pop	r0
 504:	0f be       	out	0x3f, r0	; 63
 506:	0f 90       	pop	r0
 508:	1f 90       	pop	r1
 50a:	18 95       	reti

0000050c <__vector_2>:
ISR(INT1_vect){									// External Interrupt Request 1
 50c:	1f 92       	push	r1
 50e:	0f 92       	push	r0
 510:	0f b6       	in	r0, 0x3f	; 63
 512:	0f 92       	push	r0
 514:	11 24       	eor	r1, r1
 516:	8f 93       	push	r24
 518:	9f 93       	push	r25
 51a:	af 93       	push	r26
 51c:	bf 93       	push	r27
	pulsesEncCHB ++;
 51e:	80 91 2b 01 	lds	r24, 0x012B	; 0x80012b <pulsesEncCHB>
 522:	90 91 2c 01 	lds	r25, 0x012C	; 0x80012c <pulsesEncCHB+0x1>
 526:	a0 91 2d 01 	lds	r26, 0x012D	; 0x80012d <pulsesEncCHB+0x2>
 52a:	b0 91 2e 01 	lds	r27, 0x012E	; 0x80012e <pulsesEncCHB+0x3>
 52e:	01 96       	adiw	r24, 0x01	; 1
 530:	a1 1d       	adc	r26, r1
 532:	b1 1d       	adc	r27, r1
 534:	80 93 2b 01 	sts	0x012B, r24	; 0x80012b <pulsesEncCHB>
 538:	90 93 2c 01 	sts	0x012C, r25	; 0x80012c <pulsesEncCHB+0x1>
 53c:	a0 93 2d 01 	sts	0x012D, r26	; 0x80012d <pulsesEncCHB+0x2>
 540:	b0 93 2e 01 	sts	0x012E, r27	; 0x80012e <pulsesEncCHB+0x3>
	lastInterruptChannel = 1;
 544:	81 e0       	ldi	r24, 0x01	; 1
 546:	80 93 2a 01 	sts	0x012A, r24	; 0x80012a <lastInterruptChannel>
}
 54a:	bf 91       	pop	r27
 54c:	af 91       	pop	r26
 54e:	9f 91       	pop	r25
 550:	8f 91       	pop	r24
 552:	0f 90       	pop	r0
 554:	0f be       	out	0x3f, r0	; 63
 556:	0f 90       	pop	r0
 558:	1f 90       	pop	r1
 55a:	18 95       	reti

0000055c <__vector_3>:
ISR(PCINT0_vect){								// Pin Change Interrupt Request 0
 55c:	1f 92       	push	r1
 55e:	0f 92       	push	r0
 560:	0f b6       	in	r0, 0x3f	; 63
 562:	0f 92       	push	r0
 564:	11 24       	eor	r1, r1
	ISR_PCINT0 = 0;
 566:	10 92 4f 01 	sts	0x014F, r1	; 0x80014f <ISR_PCINT0>
}
 56a:	0f 90       	pop	r0
 56c:	0f be       	out	0x3f, r0	; 63
 56e:	0f 90       	pop	r0
 570:	1f 90       	pop	r1
 572:	18 95       	reti

00000574 <__vector_4>:
ISR(PCINT1_vect){								// Pin Change Interrupt Request 1
 574:	1f 92       	push	r1
 576:	0f 92       	push	r0
 578:	0f b6       	in	r0, 0x3f	; 63
 57a:	0f 92       	push	r0
 57c:	11 24       	eor	r1, r1
	ISR_PCINT1 = 0;
 57e:	10 92 4e 01 	sts	0x014E, r1	; 0x80014e <ISR_PCINT1>
}
 582:	0f 90       	pop	r0
 584:	0f be       	out	0x3f, r0	; 63
 586:	0f 90       	pop	r0
 588:	1f 90       	pop	r1
 58a:	18 95       	reti

0000058c <__vector_5>:
ISR(PCINT2_vect){								// Pin Change Interrupt Request 2
 58c:	1f 92       	push	r1
 58e:	0f 92       	push	r0
 590:	0f b6       	in	r0, 0x3f	; 63
 592:	0f 92       	push	r0
 594:	11 24       	eor	r1, r1
	ISR_PCINT2 = 0;
 596:	10 92 4d 01 	sts	0x014D, r1	; 0x80014d <ISR_PCINT2>
}
 59a:	0f 90       	pop	r0
 59c:	0f be       	out	0x3f, r0	; 63
 59e:	0f 90       	pop	r0
 5a0:	1f 90       	pop	r1
 5a2:	18 95       	reti

000005a4 <__vector_6>:
ISR(WDT_vect){									// Watchdog Time-out Interrupt
 5a4:	1f 92       	push	r1
 5a6:	0f 92       	push	r0
 5a8:	0f b6       	in	r0, 0x3f	; 63
 5aa:	0f 92       	push	r0
 5ac:	11 24       	eor	r1, r1
	ISR_WDT = 0;
 5ae:	10 92 4c 01 	sts	0x014C, r1	; 0x80014c <ISR_WDT>
}
 5b2:	0f 90       	pop	r0
 5b4:	0f be       	out	0x3f, r0	; 63
 5b6:	0f 90       	pop	r0
 5b8:	1f 90       	pop	r1
 5ba:	18 95       	reti

000005bc <__vector_7>:
ISR(TIMER2_COMPA_vect){							// Timer/Counter 2 Compare Match A
 5bc:	1f 92       	push	r1
 5be:	0f 92       	push	r0
 5c0:	0f b6       	in	r0, 0x3f	; 63
 5c2:	0f 92       	push	r0
 5c4:	11 24       	eor	r1, r1
 5c6:	2f 93       	push	r18
 5c8:	8f 93       	push	r24
 5ca:	9f 93       	push	r25
 5cc:	af 93       	push	r26
 5ce:	bf 93       	push	r27
	microsSeconds += TIMEUNIT;					// Increment the number of microseconds by the TIMEUNIT
 5d0:	80 91 1a 01 	lds	r24, 0x011A	; 0x80011a <microsSeconds>
 5d4:	90 91 1b 01 	lds	r25, 0x011B	; 0x80011b <microsSeconds+0x1>
 5d8:	a0 91 1c 01 	lds	r26, 0x011C	; 0x80011c <microsSeconds+0x2>
 5dc:	b0 91 1d 01 	lds	r27, 0x011D	; 0x80011d <microsSeconds+0x3>
 5e0:	0a 96       	adiw	r24, 0x0a	; 10
 5e2:	a1 1d       	adc	r26, r1
 5e4:	b1 1d       	adc	r27, r1
 5e6:	80 93 1a 01 	sts	0x011A, r24	; 0x80011a <microsSeconds>
 5ea:	90 93 1b 01 	sts	0x011B, r25	; 0x80011b <microsSeconds+0x1>
 5ee:	a0 93 1c 01 	sts	0x011C, r26	; 0x80011c <microsSeconds+0x2>
 5f2:	b0 93 1d 01 	sts	0x011D, r27	; 0x80011d <microsSeconds+0x3>
	micros1000s += TIMEUNIT;					// Increment rolling counter by TIMEUNIT
 5f6:	80 91 18 01 	lds	r24, 0x0118	; 0x800118 <micros1000s>
 5fa:	90 91 19 01 	lds	r25, 0x0119	; 0x800119 <micros1000s+0x1>
 5fe:	0a 96       	adiw	r24, 0x0a	; 10
 600:	90 93 19 01 	sts	0x0119, r25	; 0x800119 <micros1000s+0x1>
 604:	80 93 18 01 	sts	0x0118, r24	; 0x800118 <micros1000s>
	if (micros1000s>=1000){
 608:	80 91 18 01 	lds	r24, 0x0118	; 0x800118 <micros1000s>
 60c:	90 91 19 01 	lds	r25, 0x0119	; 0x800119 <micros1000s+0x1>
 610:	88 3e       	cpi	r24, 0xE8	; 232
 612:	93 40       	sbci	r25, 0x03	; 3
 614:	e8 f0       	brcs	.+58     	; 0x650 <__vector_7+0x94>
		millisSeconds++;						// Increments milliseconds counter every 1000s of microseconds
 616:	80 91 1e 01 	lds	r24, 0x011E	; 0x80011e <millisSeconds>
 61a:	90 91 1f 01 	lds	r25, 0x011F	; 0x80011f <millisSeconds+0x1>
 61e:	a0 91 20 01 	lds	r26, 0x0120	; 0x800120 <millisSeconds+0x2>
 622:	b0 91 21 01 	lds	r27, 0x0121	; 0x800121 <millisSeconds+0x3>
 626:	01 96       	adiw	r24, 0x01	; 1
 628:	a1 1d       	adc	r26, r1
 62a:	b1 1d       	adc	r27, r1
 62c:	80 93 1e 01 	sts	0x011E, r24	; 0x80011e <millisSeconds>
 630:	90 93 1f 01 	sts	0x011F, r25	; 0x80011f <millisSeconds+0x1>
 634:	a0 93 20 01 	sts	0x0120, r26	; 0x800120 <millisSeconds+0x2>
 638:	b0 93 21 01 	sts	0x0121, r27	; 0x800121 <millisSeconds+0x3>
		micros1000s -= 1000;					// Adds the any extra microseconds to the rolling counter
 63c:	80 91 18 01 	lds	r24, 0x0118	; 0x800118 <micros1000s>
 640:	90 91 19 01 	lds	r25, 0x0119	; 0x800119 <micros1000s+0x1>
 644:	88 5e       	subi	r24, 0xE8	; 232
 646:	93 40       	sbci	r25, 0x03	; 3
 648:	90 93 19 01 	sts	0x0119, r25	; 0x800119 <micros1000s+0x1>
 64c:	80 93 18 01 	sts	0x0118, r24	; 0x800118 <micros1000s>
	}
}
 650:	bf 91       	pop	r27
 652:	af 91       	pop	r26
 654:	9f 91       	pop	r25
 656:	8f 91       	pop	r24
 658:	2f 91       	pop	r18
 65a:	0f 90       	pop	r0
 65c:	0f be       	out	0x3f, r0	; 63
 65e:	0f 90       	pop	r0
 660:	1f 90       	pop	r1
 662:	18 95       	reti

00000664 <__vector_8>:
ISR(TIMER2_COMPB_vect){							// Timer/Counter 2 Compare Match B
 664:	1f 92       	push	r1
 666:	0f 92       	push	r0
 668:	0f b6       	in	r0, 0x3f	; 63
 66a:	0f 92       	push	r0
 66c:	11 24       	eor	r1, r1
	ISR_TMR2CB = 0;
 66e:	10 92 4b 01 	sts	0x014B, r1	; 0x80014b <ISR_TMR2CB>
}
 672:	0f 90       	pop	r0
 674:	0f be       	out	0x3f, r0	; 63
 676:	0f 90       	pop	r0
 678:	1f 90       	pop	r1
 67a:	18 95       	reti

0000067c <__vector_9>:
ISR(TIMER2_OVF_vect){							// Timer/Counter 2 Overflow
 67c:	1f 92       	push	r1
 67e:	0f 92       	push	r0
 680:	0f b6       	in	r0, 0x3f	; 63
 682:	0f 92       	push	r0
 684:	11 24       	eor	r1, r1
	ISR_TMR2OVF = 0;
 686:	10 92 4a 01 	sts	0x014A, r1	; 0x80014a <ISR_TMR2OVF>
}
 68a:	0f 90       	pop	r0
 68c:	0f be       	out	0x3f, r0	; 63
 68e:	0f 90       	pop	r0
 690:	1f 90       	pop	r1
 692:	18 95       	reti

00000694 <__vector_10>:
ISR(TIMER1_CAPT_vect){							// Timer/Counter 1 Capture Event
 694:	1f 92       	push	r1
 696:	0f 92       	push	r0
 698:	0f b6       	in	r0, 0x3f	; 63
 69a:	0f 92       	push	r0
 69c:	11 24       	eor	r1, r1
 69e:	8f 93       	push	r24
 6a0:	9f 93       	push	r25
	ISR_TMR1CAPT = 1;
 6a2:	81 e0       	ldi	r24, 0x01	; 1
 6a4:	80 93 49 01 	sts	0x0149, r24	; 0x800149 <ISR_TMR1CAPT>
	switch (lastInterruptChannel){				// Check which encoder channel sent triggered the Input Capture
 6a8:	80 91 2a 01 	lds	r24, 0x012A	; 0x80012a <lastInterruptChannel>
 6ac:	88 23       	and	r24, r24
 6ae:	19 f0       	breq	.+6      	; 0x6b6 <__vector_10+0x22>
 6b0:	81 30       	cpi	r24, 0x01	; 1
 6b2:	91 f0       	breq	.+36     	; 0x6d8 <__vector_10+0x44>
 6b4:	21 c0       	rjmp	.+66     	; 0x6f8 <__vector_10+0x64>
		case 0:
			prevCaptTimeCHA = inCaptTimeCHA;	// Move current timestamp to the previous one
 6b6:	80 91 16 01 	lds	r24, 0x0116	; 0x800116 <inCaptTimeCHA>
 6ba:	90 91 17 01 	lds	r25, 0x0117	; 0x800117 <inCaptTimeCHA+0x1>
 6be:	90 93 13 01 	sts	0x0113, r25	; 0x800113 <prevCaptTimeCHA+0x1>
 6c2:	80 93 12 01 	sts	0x0112, r24	; 0x800112 <prevCaptTimeCHA>
			inCaptTimeCHA = ICR1;				// Update current timestamp
 6c6:	80 91 86 00 	lds	r24, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
 6ca:	90 91 87 00 	lds	r25, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
 6ce:	90 93 17 01 	sts	0x0117, r25	; 0x800117 <inCaptTimeCHA+0x1>
 6d2:	80 93 16 01 	sts	0x0116, r24	; 0x800116 <inCaptTimeCHA>
		break;
 6d6:	10 c0       	rjmp	.+32     	; 0x6f8 <__vector_10+0x64>
		case 1:
			prevCaptTimeCHB = inCaptTimeCHB;	// Move current timestamp to the previous one
 6d8:	80 91 14 01 	lds	r24, 0x0114	; 0x800114 <inCaptTimeCHB>
 6dc:	90 91 15 01 	lds	r25, 0x0115	; 0x800115 <inCaptTimeCHB+0x1>
 6e0:	90 93 11 01 	sts	0x0111, r25	; 0x800111 <prevCaptTimeCHB+0x1>
 6e4:	80 93 10 01 	sts	0x0110, r24	; 0x800110 <prevCaptTimeCHB>
			inCaptTimeCHB = ICR1;				// Update current timestamp
 6e8:	80 91 86 00 	lds	r24, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
 6ec:	90 91 87 00 	lds	r25, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
 6f0:	90 93 15 01 	sts	0x0115, r25	; 0x800115 <inCaptTimeCHB+0x1>
 6f4:	80 93 14 01 	sts	0x0114, r24	; 0x800114 <inCaptTimeCHB>
		break;
	}
}
 6f8:	9f 91       	pop	r25
 6fa:	8f 91       	pop	r24
 6fc:	0f 90       	pop	r0
 6fe:	0f be       	out	0x3f, r0	; 63
 700:	0f 90       	pop	r0
 702:	1f 90       	pop	r1
 704:	18 95       	reti

00000706 <__vector_11>:
ISR(TIMER1_COMPA_vect){							// Timer/Counter 1 Compare Match A
 706:	1f 92       	push	r1
 708:	0f 92       	push	r0
 70a:	0f b6       	in	r0, 0x3f	; 63
 70c:	0f 92       	push	r0
 70e:	11 24       	eor	r1, r1
	ISR_TMR1CA = 0;
 710:	10 92 48 01 	sts	0x0148, r1	; 0x800148 <ISR_TMR1CA>
}
 714:	0f 90       	pop	r0
 716:	0f be       	out	0x3f, r0	; 63
 718:	0f 90       	pop	r0
 71a:	1f 90       	pop	r1
 71c:	18 95       	reti

0000071e <__vector_12>:
ISR(TIMER1_COMPB_vect){							// Timer/Counter 1 Compare Match B
 71e:	1f 92       	push	r1
 720:	0f 92       	push	r0
 722:	0f b6       	in	r0, 0x3f	; 63
 724:	0f 92       	push	r0
 726:	11 24       	eor	r1, r1
	ISR_TMR1CB = 0;
 728:	10 92 47 01 	sts	0x0147, r1	; 0x800147 <ISR_TMR1CB>
}
 72c:	0f 90       	pop	r0
 72e:	0f be       	out	0x3f, r0	; 63
 730:	0f 90       	pop	r0
 732:	1f 90       	pop	r1
 734:	18 95       	reti

00000736 <__vector_13>:
ISR(TIMER1_OVF_vect){							// Timer/Counter 1 Overflow
 736:	1f 92       	push	r1
 738:	0f 92       	push	r0
 73a:	0f b6       	in	r0, 0x3f	; 63
 73c:	0f 92       	push	r0
 73e:	11 24       	eor	r1, r1
 740:	8f 93       	push	r24
	ISR_TMR1OVF = 1;
 742:	81 e0       	ldi	r24, 0x01	; 1
 744:	80 93 46 01 	sts	0x0146, r24	; 0x800146 <ISR_TMR1OVF>
}
 748:	8f 91       	pop	r24
 74a:	0f 90       	pop	r0
 74c:	0f be       	out	0x3f, r0	; 63
 74e:	0f 90       	pop	r0
 750:	1f 90       	pop	r1
 752:	18 95       	reti

00000754 <__vector_14>:
ISR(TIMER0_COMPA_vect){							// Timer/Counter 0 Compare Match A
 754:	1f 92       	push	r1
 756:	0f 92       	push	r0
 758:	0f b6       	in	r0, 0x3f	; 63
 75a:	0f 92       	push	r0
 75c:	11 24       	eor	r1, r1
	ISR_TMR0CA = 0;
 75e:	10 92 45 01 	sts	0x0145, r1	; 0x800145 <ISR_TMR0CA>
}
 762:	0f 90       	pop	r0
 764:	0f be       	out	0x3f, r0	; 63
 766:	0f 90       	pop	r0
 768:	1f 90       	pop	r1
 76a:	18 95       	reti

0000076c <__vector_15>:
ISR(TIMER0_COMPB_vect){							// Timer/Counter 0 Compare Match B
 76c:	1f 92       	push	r1
 76e:	0f 92       	push	r0
 770:	0f b6       	in	r0, 0x3f	; 63
 772:	0f 92       	push	r0
 774:	11 24       	eor	r1, r1
	ISR_TMR0CB = 0;
 776:	10 92 44 01 	sts	0x0144, r1	; 0x800144 <ISR_TMR0CB>
}
 77a:	0f 90       	pop	r0
 77c:	0f be       	out	0x3f, r0	; 63
 77e:	0f 90       	pop	r0
 780:	1f 90       	pop	r1
 782:	18 95       	reti

00000784 <__vector_16>:
ISR(TIMER0_OVF_vect){							// Timer/Counter 0 Overflow
 784:	1f 92       	push	r1
 786:	0f 92       	push	r0
 788:	0f b6       	in	r0, 0x3f	; 63
 78a:	0f 92       	push	r0
 78c:	11 24       	eor	r1, r1
	ISR_TMR0OVF = 0;
 78e:	10 92 43 01 	sts	0x0143, r1	; 0x800143 <ISR_TMR0OVF>
}
 792:	0f 90       	pop	r0
 794:	0f be       	out	0x3f, r0	; 63
 796:	0f 90       	pop	r0
 798:	1f 90       	pop	r1
 79a:	18 95       	reti

0000079c <__vector_17>:
ISR(SPI_STC_vect){								// SPI Serial Transfer Complete
 79c:	1f 92       	push	r1
 79e:	0f 92       	push	r0
 7a0:	0f b6       	in	r0, 0x3f	; 63
 7a2:	0f 92       	push	r0
 7a4:	11 24       	eor	r1, r1
	ISR_SPI = 0;
 7a6:	10 92 42 01 	sts	0x0142, r1	; 0x800142 <ISR_SPI>
}
 7aa:	0f 90       	pop	r0
 7ac:	0f be       	out	0x3f, r0	; 63
 7ae:	0f 90       	pop	r0
 7b0:	1f 90       	pop	r1
 7b2:	18 95       	reti

000007b4 <__vector_18>:
ISR(USART_RX_vect){								// USART RX Complete
 7b4:	1f 92       	push	r1
 7b6:	0f 92       	push	r0
 7b8:	0f b6       	in	r0, 0x3f	; 63
 7ba:	0f 92       	push	r0
 7bc:	11 24       	eor	r1, r1
 7be:	8f 93       	push	r24
	ISR_USARTRX = 1;							// Flag complete incoming RX
 7c0:	81 e0       	ldi	r24, 0x01	; 1
 7c2:	80 93 41 01 	sts	0x0141, r24	; 0x800141 <ISR_USARTRX>
	RXBufferAmount ++;							// Increase element count in RX buffer
 7c6:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <RXBufferAmount>
 7ca:	8f 5f       	subi	r24, 0xFF	; 255
 7cc:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <RXBufferAmount>
}
 7d0:	8f 91       	pop	r24
 7d2:	0f 90       	pop	r0
 7d4:	0f be       	out	0x3f, r0	; 63
 7d6:	0f 90       	pop	r0
 7d8:	1f 90       	pop	r1
 7da:	18 95       	reti

000007dc <__vector_19>:
ISR(USART_UDRE_vect){							// USART Data Register Empty
 7dc:	1f 92       	push	r1
 7de:	0f 92       	push	r0
 7e0:	0f b6       	in	r0, 0x3f	; 63
 7e2:	0f 92       	push	r0
 7e4:	11 24       	eor	r1, r1
 7e6:	8f 93       	push	r24
	ISR_USARTUDRE = 1;							
 7e8:	81 e0       	ldi	r24, 0x01	; 1
 7ea:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <ISR_USARTUDRE>
}
 7ee:	8f 91       	pop	r24
 7f0:	0f 90       	pop	r0
 7f2:	0f be       	out	0x3f, r0	; 63
 7f4:	0f 90       	pop	r0
 7f6:	1f 90       	pop	r1
 7f8:	18 95       	reti

000007fa <__vector_20>:
ISR(USART_TX_vect){								// USART TX Complete
 7fa:	1f 92       	push	r1
 7fc:	0f 92       	push	r0
 7fe:	0f b6       	in	r0, 0x3f	; 63
 800:	0f 92       	push	r0
 802:	11 24       	eor	r1, r1
 804:	8f 93       	push	r24
	ISR_USARTTX = 1;							// Flag complete TX
 806:	81 e0       	ldi	r24, 0x01	; 1
 808:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <ISR_USARTTX>
	TXBufferAmount --;							// Decrease elements count in TX buffer
 80c:	80 91 35 01 	lds	r24, 0x0135	; 0x800135 <TXBufferAmount>
 810:	81 50       	subi	r24, 0x01	; 1
 812:	80 93 35 01 	sts	0x0135, r24	; 0x800135 <TXBufferAmount>
}
 816:	8f 91       	pop	r24
 818:	0f 90       	pop	r0
 81a:	0f be       	out	0x3f, r0	; 63
 81c:	0f 90       	pop	r0
 81e:	1f 90       	pop	r1
 820:	18 95       	reti

00000822 <__vector_21>:
ISR(ADC_vect){									// ADC Conversion Complete
 822:	1f 92       	push	r1
 824:	0f 92       	push	r0
 826:	0f b6       	in	r0, 0x3f	; 63
 828:	0f 92       	push	r0
 82a:	11 24       	eor	r1, r1
 82c:	8f 93       	push	r24
	ISR_ADC = 1;								// 
 82e:	81 e0       	ldi	r24, 0x01	; 1
 830:	80 93 40 01 	sts	0x0140, r24	; 0x800140 <ISR_ADC>
}
 834:	8f 91       	pop	r24
 836:	0f 90       	pop	r0
 838:	0f be       	out	0x3f, r0	; 63
 83a:	0f 90       	pop	r0
 83c:	1f 90       	pop	r1
 83e:	18 95       	reti

00000840 <__vector_22>:
ISR(EE_READY_vect){								// EEPROM Ready
 840:	1f 92       	push	r1
 842:	0f 92       	push	r0
 844:	0f b6       	in	r0, 0x3f	; 63
 846:	0f 92       	push	r0
 848:	11 24       	eor	r1, r1
	ISR_EEREADY = 0;
 84a:	10 92 3f 01 	sts	0x013F, r1	; 0x80013f <ISR_EEREADY>
}
 84e:	0f 90       	pop	r0
 850:	0f be       	out	0x3f, r0	; 63
 852:	0f 90       	pop	r0
 854:	1f 90       	pop	r1
 856:	18 95       	reti

00000858 <__vector_23>:
ISR(ANALOG_COMP_vect){							// Analog Comparator
 858:	1f 92       	push	r1
 85a:	0f 92       	push	r0
 85c:	0f b6       	in	r0, 0x3f	; 63
 85e:	0f 92       	push	r0
 860:	11 24       	eor	r1, r1
	ISR_ANALOGCOMP = 0;
 862:	10 92 3e 01 	sts	0x013E, r1	; 0x80013e <ISR_ANALOGCOMP>
}
 866:	0f 90       	pop	r0
 868:	0f be       	out	0x3f, r0	; 63
 86a:	0f 90       	pop	r0
 86c:	1f 90       	pop	r1
 86e:	18 95       	reti

00000870 <__vector_24>:
ISR(TWI_vect){									// 2-wire Serial Interface
 870:	1f 92       	push	r1
 872:	0f 92       	push	r0
 874:	0f b6       	in	r0, 0x3f	; 63
 876:	0f 92       	push	r0
 878:	11 24       	eor	r1, r1
 87a:	8f 93       	push	r24
 87c:	ef 93       	push	r30
 87e:	ff 93       	push	r31
	ISR_TWI = 0;
 880:	10 92 3d 01 	sts	0x013D, r1	; 0x80013d <ISR_TWI>
	switch(TWSR & 0b11111100){					// Masking prescaler bits in TWSR
 884:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
 888:	8c 7f       	andi	r24, 0xFC	; 252
 88a:	82 31       	cpi	r24, 0x12	; 18
 88c:	71 f0       	breq	.+28     	; 0x8aa <__vector_24+0x3a>
 88e:	8c 31       	cpi	r24, 0x1C	; 28
 890:	b1 f0       	breq	.+44     	; 0x8be <__vector_24+0x4e>
 892:	88 30       	cpi	r24, 0x08	; 8
 894:	c9 f4       	brne	.+50     	; 0x8c8 <__vector_24+0x58>
		case 8:									// A START condition has been transmitted
			TWDR = I2CRemoteAddress;
 896:	80 91 33 01 	lds	r24, 0x0133	; 0x800133 <I2CRemoteAddress>
 89a:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
			TWCR |= (0<<TWSTA) | (0<<TWSTO) | (1<<TWINT);
 89e:	ec eb       	ldi	r30, 0xBC	; 188
 8a0:	f0 e0       	ldi	r31, 0x00	; 0
 8a2:	80 81       	ld	r24, Z
 8a4:	80 68       	ori	r24, 0x80	; 128
 8a6:	80 83       	st	Z, r24
		break;
 8a8:	0f c0       	rjmp	.+30     	; 0x8c8 <__vector_24+0x58>
		case 10:								// A repeated START condition has been transmitted
		break;
		case 18:								// SLA+W has been transmitted; ACK has been received
			TWDR = I2CData;
 8aa:	80 91 34 01 	lds	r24, 0x0134	; 0x800134 <I2CData>
 8ae:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
			TWCR |= (0<<TWSTA) | (0<<TWSTO) | (1<<TWINT);
 8b2:	ec eb       	ldi	r30, 0xBC	; 188
 8b4:	f0 e0       	ldi	r31, 0x00	; 0
 8b6:	80 81       	ld	r24, Z
 8b8:	80 68       	ori	r24, 0x80	; 128
 8ba:	80 83       	st	Z, r24
		break;
 8bc:	05 c0       	rjmp	.+10     	; 0x8c8 <__vector_24+0x58>
		case 20:								// SLA+W has been transmitted; NOT ACK has been received
			//setError(I2C_SLA_NOK_RESPONSE);
		break;
		case 28:								// Data byte has been transmitted; ACK has been received
			TWCR |= (0<<TWSTA) | (1<<TWSTO) | (1<<TWINT);
 8be:	ec eb       	ldi	r30, 0xBC	; 188
 8c0:	f0 e0       	ldi	r31, 0x00	; 0
 8c2:	80 81       	ld	r24, Z
 8c4:	80 69       	ori	r24, 0x90	; 144
 8c6:	80 83       	st	Z, r24
		break;
		default:
			//setError(I2C_UNKNOWN_ERROR);
		break;		
	}
}
 8c8:	ff 91       	pop	r31
 8ca:	ef 91       	pop	r30
 8cc:	8f 91       	pop	r24
 8ce:	0f 90       	pop	r0
 8d0:	0f be       	out	0x3f, r0	; 63
 8d2:	0f 90       	pop	r0
 8d4:	1f 90       	pop	r1
 8d6:	18 95       	reti

000008d8 <__vector_25>:
ISR(SPM_READY_vect){							// Store Program Memory Ready
 8d8:	1f 92       	push	r1
 8da:	0f 92       	push	r0
 8dc:	0f b6       	in	r0, 0x3f	; 63
 8de:	0f 92       	push	r0
 8e0:	11 24       	eor	r1, r1
	ISR_SPM = 0;
 8e2:	10 92 3c 01 	sts	0x013C, r1	; 0x80013c <ISR_SPM>
}
 8e6:	0f 90       	pop	r0
 8e8:	0f be       	out	0x3f, r0	; 63
 8ea:	0f 90       	pop	r0
 8ec:	1f 90       	pop	r1
 8ee:	18 95       	reti

000008f0 <__udivmodsi4>:
 8f0:	a1 e2       	ldi	r26, 0x21	; 33
 8f2:	1a 2e       	mov	r1, r26
 8f4:	aa 1b       	sub	r26, r26
 8f6:	bb 1b       	sub	r27, r27
 8f8:	fd 01       	movw	r30, r26
 8fa:	0d c0       	rjmp	.+26     	; 0x916 <__udivmodsi4_ep>

000008fc <__udivmodsi4_loop>:
 8fc:	aa 1f       	adc	r26, r26
 8fe:	bb 1f       	adc	r27, r27
 900:	ee 1f       	adc	r30, r30
 902:	ff 1f       	adc	r31, r31
 904:	a2 17       	cp	r26, r18
 906:	b3 07       	cpc	r27, r19
 908:	e4 07       	cpc	r30, r20
 90a:	f5 07       	cpc	r31, r21
 90c:	20 f0       	brcs	.+8      	; 0x916 <__udivmodsi4_ep>
 90e:	a2 1b       	sub	r26, r18
 910:	b3 0b       	sbc	r27, r19
 912:	e4 0b       	sbc	r30, r20
 914:	f5 0b       	sbc	r31, r21

00000916 <__udivmodsi4_ep>:
 916:	66 1f       	adc	r22, r22
 918:	77 1f       	adc	r23, r23
 91a:	88 1f       	adc	r24, r24
 91c:	99 1f       	adc	r25, r25
 91e:	1a 94       	dec	r1
 920:	69 f7       	brne	.-38     	; 0x8fc <__udivmodsi4_loop>
 922:	60 95       	com	r22
 924:	70 95       	com	r23
 926:	80 95       	com	r24
 928:	90 95       	com	r25
 92a:	9b 01       	movw	r18, r22
 92c:	ac 01       	movw	r20, r24
 92e:	bd 01       	movw	r22, r26
 930:	cf 01       	movw	r24, r30
 932:	08 95       	ret

00000934 <__divmodsi4>:
 934:	05 2e       	mov	r0, r21
 936:	97 fb       	bst	r25, 7
 938:	1e f4       	brtc	.+6      	; 0x940 <__divmodsi4+0xc>
 93a:	00 94       	com	r0
 93c:	0e 94 b1 04 	call	0x962	; 0x962 <__negsi2>
 940:	57 fd       	sbrc	r21, 7
 942:	07 d0       	rcall	.+14     	; 0x952 <__divmodsi4_neg2>
 944:	0e 94 78 04 	call	0x8f0	; 0x8f0 <__udivmodsi4>
 948:	07 fc       	sbrc	r0, 7
 94a:	03 d0       	rcall	.+6      	; 0x952 <__divmodsi4_neg2>
 94c:	4e f4       	brtc	.+18     	; 0x960 <__divmodsi4_exit>
 94e:	0c 94 b1 04 	jmp	0x962	; 0x962 <__negsi2>

00000952 <__divmodsi4_neg2>:
 952:	50 95       	com	r21
 954:	40 95       	com	r20
 956:	30 95       	com	r19
 958:	21 95       	neg	r18
 95a:	3f 4f       	sbci	r19, 0xFF	; 255
 95c:	4f 4f       	sbci	r20, 0xFF	; 255
 95e:	5f 4f       	sbci	r21, 0xFF	; 255

00000960 <__divmodsi4_exit>:
 960:	08 95       	ret

00000962 <__negsi2>:
 962:	90 95       	com	r25
 964:	80 95       	com	r24
 966:	70 95       	com	r23
 968:	61 95       	neg	r22
 96a:	7f 4f       	sbci	r23, 0xFF	; 255
 96c:	8f 4f       	sbci	r24, 0xFF	; 255
 96e:	9f 4f       	sbci	r25, 0xFF	; 255
 970:	08 95       	ret

00000972 <__umulhisi3>:
 972:	a2 9f       	mul	r26, r18
 974:	b0 01       	movw	r22, r0
 976:	b3 9f       	mul	r27, r19
 978:	c0 01       	movw	r24, r0
 97a:	a3 9f       	mul	r26, r19
 97c:	70 0d       	add	r23, r0
 97e:	81 1d       	adc	r24, r1
 980:	11 24       	eor	r1, r1
 982:	91 1d       	adc	r25, r1
 984:	b2 9f       	mul	r27, r18
 986:	70 0d       	add	r23, r0
 988:	81 1d       	adc	r24, r1
 98a:	11 24       	eor	r1, r1
 98c:	91 1d       	adc	r25, r1
 98e:	08 95       	ret

00000990 <_exit>:
 990:	f8 94       	cli

00000992 <__stop_program>:
 992:	ff cf       	rjmp	.-2      	; 0x992 <__stop_program>
